## 概述
JS内部，所有数字都是以64位浮点数形式存储，即使整数也是如此。<br/>
所以，`1` 与 `1.0` 是同一个数。
这就是说，在JS底层，根本没有整数，所有数字都是小数(64位浮点数)。
容易造成混淆的是，某些运算只有整数才能完成，此时JS会把64位浮点数转成32位整数，然后再进行运算。

由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心。

    0.1 + 0.2 === 0.3
    // false

    0.3 / 0.1
    // 2.9999999999999996

    (0.3 - 0.2) === (0.2 - 0.1)
    // false

#### > 数值精度
JS浮点数的64个二进制位，从最左边开始的组成：

    第1位：符号位，0表示正数，1表示负数
    第2位到第12位：储存指数部分
    第13位到第64位：储存小数部分（即有效数字）

符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。

## 特殊数值
#### > 正零和负零
JS的64位浮点数之中，有一个二进制位是符号位。
这意味着，任何一个数都有正值和负值，就连0都不例外。

在JS内部，实际上存在2个0：一个`+0`，一个`-0`。它们是等价的。

    -0 === +0 // true
    0 === -0 // true
    0 === +0 // true

几乎所有场合，正零和负零都会被当作正常的零。
唯一有区别的是，零被当作分母。结果为一个正无穷、一个负无穷。

    (1 / +0) === (1 / -0) // false

#### > NaN
NaN是JS中的一个特殊值，主要出现在将字符串转为数字出错的场合。

##### >> 运算规则
NaN不等于任何值，包括它自身。
由于数组的indexOf方法，内部使用的是严格相等运算符，所以该方法对NaN不成立。

    NaN === NaN // false
    [NaN].indexOf(NaN) // -1

##### >> 判断NaN的方法
isNaN方法可以用来判断一个值是否为NaN。
但是该方法只对数值有效，如果传入其他值，会被先转为数值。
比如，传入字符串的时候，如果不能转为数值，字符串就会转为NaN，所以最后返回true。

    isNaN('Hello') // true
    // 相当于
    isNaN(Number('Hello')) // true

出于同样的原因，对于对象和数组，isNaN也返回true。

    isNaN({}) // true
    // 等同于
    isNaN(Number({})) // true

    isNaN(['xzy']) // true
    // 等同于
    isNaN(Number(['xzy'])) // true

但是，对于空数组和只有一个数值成员的数组，isNaN会返回false。
之所以会出现这样的结果，原因是这些数组能被Number函数转为数值。

    isNaN([]) // false
    isNaN([123]) // false
    isNaN(['123']) // false

因此，使用isNaN方法之前，最好先判断一下数据类型。

    function myIsNaN(value) {
      return typeof value === 'number' && isNaN(value);
    }

    //根据自身特性，NaN不等于任何值
    function myIsNaN(value) {
      return value !== value;
    }

## 与数值相关的全局方法
#### > parseInt(将字符串转为整数)
- 如果字符串头部有空格，空格会被自动去除。
- 如果参数不是字符串、数值，或者第一个字符不能转化为整数，则返回NaN。
- 转换的时候是一个个字符依次转换的，如果遇到不能转为数字的字符，就会停止转换，返回已经转换好的部分。
- 如果字符串符合科学计数法，得到的是一些奇怪的结果。

#### > parseFloat(将字符串转为浮点数)
- 如果字符串头部有空格，空格会被自动去除。
- 如果参数不是字符串、数值，或者第一个字符不能转化为浮点数，则返回NaN。
- 转换的时候是一个个字符依次转换的，如果遇到不能转为数字的字符，就会停止转换，返回已经转换好的部分。
- 如果字符串符合科学计数法，则会进行相应的转换。